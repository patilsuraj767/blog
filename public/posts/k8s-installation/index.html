<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kubernetes Installation Bash/Kickstart Script | </title>
<meta name="keywords" content="">
<meta name="description" content="Many times we as developers come across a scenario where we require a Kubernetes cluster for testing or for hosting some application. Minikube and kind clusters are good for the local setup, and I use them in my day to day development work on local systems, but when it comes to installing Kubernetes on cloud instances I usually prefer to have a stock/vanilla Kubernetes cluster installed using Kubeadm, it gives me a sense of having more control over the cluster.">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/k8s-installation/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/k8s-installation/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Kubernetes Installation Bash/Kickstart Script" />
<meta property="og:description" content="Many times we as developers come across a scenario where we require a Kubernetes cluster for testing or for hosting some application. Minikube and kind clusters are good for the local setup, and I use them in my day to day development work on local systems, but when it comes to installing Kubernetes on cloud instances I usually prefer to have a stock/vanilla Kubernetes cluster installed using Kubeadm, it gives me a sense of having more control over the cluster." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.org/posts/k8s-installation/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-08-24T08:35:28+05:30" />
<meta property="article:modified_time" content="2024-08-24T08:35:28+05:30" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kubernetes Installation Bash/Kickstart Script"/>
<meta name="twitter:description" content="Many times we as developers come across a scenario where we require a Kubernetes cluster for testing or for hosting some application. Minikube and kind clusters are good for the local setup, and I use them in my day to day development work on local systems, but when it comes to installing Kubernetes on cloud instances I usually prefer to have a stock/vanilla Kubernetes cluster installed using Kubeadm, it gives me a sense of having more control over the cluster."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kubernetes Installation Bash/Kickstart Script",
      "item": "https://example.org/posts/k8s-installation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes Installation Bash/Kickstart Script",
  "name": "Kubernetes Installation Bash\/Kickstart Script",
  "description": "Many times we as developers come across a scenario where we require a Kubernetes cluster for testing or for hosting some application. Minikube and kind clusters are good for the local setup, and I use them in my day to day development work on local systems, but when it comes to installing Kubernetes on cloud instances I usually prefer to have a stock/vanilla Kubernetes cluster installed using Kubeadm, it gives me a sense of having more control over the cluster.",
  "keywords": [
    
  ],
  "articleBody": "Many times we as developers come across a scenario where we require a Kubernetes cluster for testing or for hosting some application. Minikube and kind clusters are good for the local setup, and I use them in my day to day development work on local systems, but when it comes to installing Kubernetes on cloud instances I usually prefer to have a stock/vanilla Kubernetes cluster installed using Kubeadm, it gives me a sense of having more control over the cluster. Routing, adding firewall rules and testing new CNCF projects get simpler.\nI know we can directly leverage cloud services like EKS and AKS to get the Kubernetes cluster, but it comes with the extra cost. Also, somewhere in the back of mind, I also think what other cloud configuration might be getting changed by deploying EKS and AKS cluster. Also, while testing new projects I blindly copy and paste the Kubectl commands, and suppose if by mistake we created a k8s service using type loadbalancer than cloud provider will deploy an external load balancer and charge us separately.\nI have created the below script, which can be run on any instance (local VM or cloud instance) of Ubuntu to install the stock/vanilla kubernetes cluster in just a few minutes.\n#!/bin/bash # Installing docker sudo apt-get update -y sudo apt-get install ca-certificates curl -y sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release \u0026\u0026 echo \"$VERSION_CODENAME\") stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null sudo apt-get update -y sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y # Installing kubectl curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl rm -rf kubectl sudo swapoff -a sudo apt-get install -y apt-transport-https ca-certificates curl gpg -y curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl sudo apt-mark hold kubelet kubeadm kubectl sudo systemctl enable --now kubelet # Installing cri-dockerd VER=$(curl -s https://api.github.com/repos/Mirantis/cri-dockerd/releases/latest|grep tag_name | cut -d '\"' -f 4) echo $VER wget https://github.com/Mirantis/cri-dockerd/releases/download/${VER}/cri-dockerd-$(echo $VER | cut -c2- ).amd64.tgz tar xvf cri-dockerd-$(echo $VER | cut -c2- ).amd64.tgz sudo mv cri-dockerd/cri-dockerd /usr/local/bin/ cri-dockerd --version rm -rf cri-dockerd* wget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service -O /etc/systemd/system/cri-docker.service wget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket -O /etc/systemd/system/cri-docker.socket sudo sed -i -e 's,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,' /etc/systemd/system/cri-docker.service sudo systemctl daemon-reload sudo systemctl enable cri-docker.service sudo systemctl start cri-docker.socket # Installing cluster kubeadm init --pod-network-cidr=192.168.0.0/16 --cri-socket unix:///var/run/cri-dockerd.sock mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config # Install calico kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/tigera-operator.yaml kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/custom-resources.yaml kubectl taint nodes --all node-role.kubernetes.io/control-plane- Above script can also be pasted in the user-data/cloud-init section while creating a cloud instance. If we use the script in the cloud-init, than to configure kubectl we will need to explicitly run the below commmands after instance it spinned up.\nmkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config ",
  "wordCount" : "503",
  "inLanguage": "en",
  "datePublished": "2024-08-24T08:35:28+05:30",
  "dateModified": "2024-08-24T08:35:28+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/k8s-installation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://example.org/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://example.org/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://example.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kubernetes Installation Bash/Kickstart Script
    </h1>
    <div class="post-meta"><span title='2024-08-24 08:35:28 +0530 IST'>August 24, 2024</span>

</div>
  </header> 
  <div class="post-content"><p>Many times we as developers come across a scenario where we require a Kubernetes cluster for testing or for hosting some application. Minikube and kind clusters are good for the local setup, and I use them in my day to day development work on local systems, but when it comes to installing Kubernetes on cloud instances I usually prefer to have a stock/vanilla Kubernetes cluster installed using Kubeadm, it gives me a sense of having more control over the cluster. Routing, adding firewall rules and testing new CNCF projects get simpler.</p>
<p>I know we can directly leverage cloud services like EKS and AKS to get the Kubernetes cluster, but it comes with the extra cost. Also, somewhere in the back of mind, I also think what other cloud configuration might be getting changed by deploying EKS and AKS cluster.
Also, while testing new projects I blindly copy and paste the Kubectl commands, and suppose if by mistake we created a k8s service using type loadbalancer than cloud provider will deploy an external load balancer and charge us separately.</p>
<p>I have created the below script, which can be run on any instance (local VM or cloud instance) of Ubuntu to install the stock/vanilla kubernetes cluster in just a few minutes.</p>
<pre tabindex="0"><code>#!/bin/bash

# Installing docker

sudo apt-get update -y
sudo apt-get install ca-certificates curl -y
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

echo \
  &#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release &amp;&amp; echo &#34;$VERSION_CODENAME&#34;) stable&#34; | \
  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

sudo apt-get update -y
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y


# Installing kubectl

curl -LO &#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&#34;
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
rm -rf kubectl


sudo swapoff -a
sudo apt-get install -y apt-transport-https ca-certificates curl gpg -y
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

echo &#39;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /&#39; | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
sudo systemctl enable --now kubelet

# Installing cri-dockerd

VER=$(curl -s https://api.github.com/repos/Mirantis/cri-dockerd/releases/latest|grep tag_name | cut -d &#39;&#34;&#39; -f 4)
echo $VER
wget https://github.com/Mirantis/cri-dockerd/releases/download/${VER}/cri-dockerd-$(echo $VER | cut -c2- ).amd64.tgz
tar xvf cri-dockerd-$(echo $VER | cut -c2- ).amd64.tgz
sudo mv cri-dockerd/cri-dockerd /usr/local/bin/
cri-dockerd --version
rm -rf cri-dockerd*
wget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service -O /etc/systemd/system/cri-docker.service
wget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket -O /etc/systemd/system/cri-docker.socket
sudo sed -i -e &#39;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#39; /etc/systemd/system/cri-docker.service
sudo systemctl daemon-reload
sudo systemctl enable cri-docker.service
sudo systemctl start cri-docker.socket


# Installing cluster
kubeadm init --pod-network-cidr=192.168.0.0/16 --cri-socket unix:///var/run/cri-dockerd.sock

mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# Install calico
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/tigera-operator.yaml
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/custom-resources.yaml
kubectl taint nodes --all node-role.kubernetes.io/control-plane-
</code></pre><p>Above script can also be pasted in the user-data/cloud-init section while creating a cloud instance.
If we use the script in the cloud-init, than to configure kubectl we will need to explicitly run the below commmands after instance it spinned up.</p>
<pre tabindex="0"><code>mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
